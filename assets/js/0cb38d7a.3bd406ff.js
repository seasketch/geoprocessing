"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[89601],{61223:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=n(74848),o=n(28453);const r={},i="Creating a geoprocessing function",a={id:"tutorials/createGeoprocessing",title:"Creating a geoprocessing function",description:"The create",source:"@site/docs/tutorials/createGeoprocessing.md",sourceDirName:"tutorials",slug:"/tutorials/createGeoprocessing",permalink:"/geoprocessing/docs/next/tutorials/createGeoprocessing",draft:!1,unlisted:!1,editUrl:"https://github.com/seasketch/geoprocessing/tree/main/website/templates/shared/docs/tutorials/createGeoprocessing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Deploy Project",permalink:"/geoprocessing/docs/next/tutorials/deploy"},next:{title:"New Report Client",permalink:"/geoprocessing/docs/next/tutorials/createReport"}},c={},l=[];function h(e){const t={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"creating-a-geoprocessing-function",children:"Creating a geoprocessing function"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"create:report"})," function builds both a geoprocessing function and component based on a metric group. If you instead wish to strictly create a function, you can use:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"npm run create:function\n"})}),"\n",(0,s.jsx)(t.p,{children:"Enter some information about this function:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"? Function type Geoprocessing - For sketch reports\n? Title for this function, in camelCase simpleFunction\n? Describe what this function does Calculates area overlap with coral cover dataset\n? Choose an execution mode Async - Better for long-running processes\n"})}),"\n",(0,s.jsx)(t.p,{children:"The command should then return the following output:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\u2714 created simpleFunction function in src/functions/\n\nGeoprocessing function initialized\n\nNext Steps:\n  * Update your function definition in src/functions/simpleFunction.ts\n  * Smoke test in simpleFunctionSmoke.test.ts will be run the next time you execute 'npm test'\n  * Populate examples/sketches folder with sketches for smoke test to run against\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The function will have been added to ",(0,s.jsx)(t.code,{children:"project/geoprocessing.json"})," in the ",(0,s.jsx)(t.code,{children:"geoprocessingFunctions"})," section."]}),"\n",(0,s.jsxs)(t.p,{children:["The geoprocessing function file starts off with boilerplate code every geoprocessing function should have. It then includes an example of loading both vector data and raster data from ",(0,s.jsx)(t.a,{href:"https://github.com/seasketch/global-datasources",children:"global datasources"})," and calculating some simple stats, and returning a ",(0,s.jsx)(t.code,{children:"Result"})," payload. To explain in more detail:"]}),"\n",(0,s.jsxs)(t.p,{children:["First a Typescript interface is defined that defines the shape of the data that the geoprocessing function will return. This defines an ",(0,s.jsx)(t.code,{children:"object"})," with properties ",(0,s.jsx)(t.code,{children:"area"})," and ",(0,s.jsx)(t.code,{children:"nearbyEcoregions"}),", ",(0,s.jsx)(t.code,{children:"minTemp"}),", and ",(0,s.jsx)(t.code,{children:"maxTemp"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"export interface SimpleResults {\n  /** area of sketch within geography in square meters */\n  area: number;\n  /** list of ecoregions within bounding box of sketch  */\n  nearbyEcoregions: string[];\n  /** minimum surface temperature within sketch */\n  minTemp: number;\n  /** maximum surface temperature within sketch */\n  maxTemp: number;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then comes the actual geoprocessing function, which accepts a ",(0,s.jsx)(t.code,{children:"sketch"})," as its first parameters. It can be either a single Sketch Polygon/Multipolygon, or a SketchCollection containing Polygons/MultiPolygons. The second parameter is ",(0,s.jsx)(t.code,{children:"extraParams"}),", which is an object that may contain [one or more identifiers] passed by the report client when invoking the geoprocessing function (",(0,s.jsx)(t.a,{href:"https://seasketch.github.io/geoprocessing/api/interfaces/geoprocessing.DefaultExtraParams.html",children:"https://seasketch.github.io/geoprocessing/api/interfaces/geoprocessing.DefaultExtraParams.html"}),")"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"async function yourFunction(\n  sketch:\n    | Sketch<Polygon | MultiPolygon>\n    | SketchCollection<Polygon | MultiPolygon>,\n  extraParams: DefaultExtraParams = {}\n): Promise<AreaResults> {\n"})}),"\n",(0,s.jsxs)(t.p,{children:["First, the function will get any ",(0,s.jsx)(t.code,{children:"geographyIds"})," that may have been passed by the report client via ",(0,s.jsx)(t.code,{children:"extraParams"})," to specify which geography to run the function for. It will then use ",(0,s.jsx)(t.code,{children:"getGeographyById"})," to get the geography object with that id from ",(0,s.jsx)(t.code,{children:"geographies.json"}),". If the ",(0,s.jsx)(t.code,{children:"geographyId"})," is undefined, then it will return the default geography."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Use caller-provided geographyId if provided\nconst geographyId = getFirstFromParam("geographyIds", extraParams);\n// Get geography features, falling back to geography assigned to default-boundary group\nconst curGeography = project.getGeographyById(geographyId, {\n  fallbackGroup: "default-boundary",\n});\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Next, the function will handle the situation where the ",(0,s.jsx)(t.code,{children:"sketch"})," crosses the 180 degree antimeridian (essentially the dateline) by calling ",(0,s.jsx)(t.code,{children:"splitSketchAntimeridian"}),". If the sketch crosses the antimeridian, it will clean (adjust) the coordinates to all be within -180 to 180 degrees. Then it will split the sketch into two pieces, one on the left side of the antimeridan, one on the right side. This splitting is required by many spatial libraries to perform operations on the sketch. Vector datasources are also split on import for this reason."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Support sketches crossing antimeridian\nconst splitSketch = splitSketchAntimeridian(sketch);\n"})}),"\n",(0,s.jsx)(t.p,{children:"After that, the sketch is clipped to the current geography, so that only the portion of the sketch that is within the geography remains."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Clip to portion of sketch within current geography\nconst clippedSketch = await clipToGeography(splitSketch, curGeography);\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now we get to the core of what this particularly geoprocessing function is designed to do. Think of this as a starting point that you can adapt to meet your needs."}),"\n",(0,s.jsxs)(t.p,{children:["First, we'll fetch the ",(0,s.jsx)(t.a,{href:"https://github.com/seasketch/global-datasources?tab=readme-ov-file#marine-ecoregions-of-the-world",children:"Marine Ecoregions of the World"})," polygon features that overlap with the bounding box of the ",(0,s.jsx)(t.code,{children:"clippedSketch"}),". Then reduce this down to an array of ecoregion names. You could take this further to reduce down to only the ecoregions that intersect with the sketch."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Fetch eez features overlapping sketch bbox\nconst ds = project.getExternalVectorDatasourceById("meow-ecos");\nconst url = project.getDatasourceUrl(ds);\nconst eezFeatures = await getFeatures(ds, url, {\n  bbox: clippedSketch.bbox || bbox(clippedSketch),\n});\n\n// Reduce to list of ecoregion names\nconst regionNames = eezFeatures.reduce<Record<string, string>>(\n  (regionsSoFar, curFeat) => {\n    if (curFeat.properties && ds.idProperty) {\n      const regionName = curFeat.properties[ds.idProperty];\n      return { ...regionsSoFar, [regionName]: regionName };\n    } else {\n      return { ...regionsSoFar, unknown: "unknown" };\n    }\n  },\n  {},\n);\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Next, we'll fetch all the ",(0,s.jsx)(t.a,{href:"https://github.com/seasketch/global-datasources?tab=readme-ov-file#biooracle-present-day-surface-temperature-maximum",children:"minimum"})," and ",(0,s.jsx)(t.a,{href:"https://github.com/seasketch/global-datasources?tab=readme-ov-file#biooracle-present-day-surface-temperature-maximum",children:"maximum"})," surface temperature measurements within the ",(0,s.jsx)(t.code,{children:"clippedSketch"})," and then calculate the single minimum and maximum values."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'const minDs = project.getRasterDatasourceById("bo-present-surface-temp-min");\nconst minUrl = project.getDatasourceUrl(minDs);\nconst minRaster = await loadCog(minUrl);\nconst minResult = await geoblaze.min(minRaster, clippedSketch);\nconst minTemp = minResult[0]; // extract value from band 1\n\nconst maxDs = project.getRasterDatasourceById("bo-present-surface-temp-max");\nconst maxUrl = project.getDatasourceUrl(maxDs);\nconst maxRaster = await loadCog(maxUrl);\nconst maxResult = await geoblaze.max(maxRaster, clippedSketch);\nconst maxTemp = maxResult[0]; // extract value from band 1\n'})}),"\n",(0,s.jsx)(t.p,{children:"The final step of the function is always to return the result payload back to the report client"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"return {\n  area: turfArea(clippedSketch),\n  nearbyEcoregions: Object.keys(regionNames),\n  minTemp,\n  maxTemp,\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["At the bottom of the file, the geoprocessing function is wrapped into a ",(0,s.jsx)(t.code,{children:"GeoprocessingHandler"})," which is what gets exported by the file. This handler provides what the geoprocessing function needs to run in an AWS Lambda environemnt, specifically to be called via REST API by a report client, receive input parameters and send back function results. It also lets you fine tune the hardware characteristics of the Lambda to meet performance requirements at the lowest cost. Specifically, you can increase the memory available to the Lambda up to ",(0,s.jsx)(t.code,{children:"10240"})," KB, which will also increase the cpu size and number. You can also increase the timeout up ",(0,s.jsx)(t.code,{children:"900"})," seconds or 15 minutes for long running analysis, though ",(0,s.jsx)(t.code,{children:"180"})," - ",(0,s.jsx)(t.code,{children:"300"})," seconds is probably the longest amount a user is willing to wait. You will want to use an ",(0,s.jsx)(t.code,{children:"async"})," function over ",(0,s.jsx)(t.code,{children:"sync"})," if the function runs for more than say 5 seconds with a typical payload. The ",(0,s.jsx)(t.code,{children:"title"})," and ",(0,s.jsx)(t.code,{children:"description"})," fields are published in the projects service manifest to list what functions are available."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'export default new GeoprocessingHandler(calculateArea, {\n  title: "calculateArea",\n  description: "Function description",\n  timeout: 60, // seconds\n  memory: 1024, // megabytes\n  executionMode: "async",\n  // Specify any Sketch Class form attributes that are required\n  requiresProperties: [],\n});\n'})}),"\n",(0,s.jsx)(t.p,{children:"To publish your new function:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Add it to the ",(0,s.jsx)(t.code,{children:"project/geoprocessing.json"})," file under the ",(0,s.jsx)(t.code,{children:"geoprocessingFunctions"})," section."]}),"\n",(0,s.jsx)(t.li,{children:"Build and publish your project as normal."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(96540);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);