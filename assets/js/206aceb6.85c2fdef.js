"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[46138],{41005:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=t(74848),r=t(28453);const a={},o="Adding and Passing Extra Parameters",i={id:"tutorials/extraParams",title:"Adding and Passing Extra Parameters",description:"Sometimes you want to pass additional parameters to a preprocessing or geoprocessing function that are defined outside of the sketch creation process by seasketch or through the report itself. These extraParams are separate from the sketch. They are an additional object passed to every preprocessing and geoprocessing function.",source:"@site/docs/tutorials/extraParams.md",sourceDirName:"tutorials",slug:"/tutorials/extraParams",permalink:"/geoprocessing/docs/next/tutorials/extraParams",draft:!1,unlisted:!1,editUrl:"https://github.com/seasketch/geoprocessing/tree/main/website/templates/shared/docs/tutorials/extraParams.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Custom Sketch Attributes",permalink:"/geoprocessing/docs/next/tutorials/sketchAttributes"},next:{title:"Subdividing Data",permalink:"/geoprocessing/docs/next/tutorials/subdividing"}},c={},l=[{value:"Passing Extra Parameters To Geoprocessing Functions",id:"passing-extra-parameters-to-geoprocessing-functions",level:2},{value:"Accessing Extra Parameters In Functions",id:"accessing-extra-parameters-in-functions",level:2},{value:"Writing smoke tests with extraParams",id:"writing-smoke-tests-with-extraparams",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adding-and-passing-extra-parameters",children:"Adding and Passing Extra Parameters"})}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you want to pass additional parameters to a preprocessing or geoprocessing function that are defined outside of the sketch creation process by seasketch or through the report itself. These ",(0,s.jsx)(n.code,{children:"extraParams"})," are separate from the ",(0,s.jsx)(n.code,{children:"sketch"}),". They are an additional object passed to every preprocessing and geoprocessing function."]}),"\n",(0,s.jsx)(n.p,{children:"Extra parameters should be JSON serializable. Strings, numbers, objects, etc. but no functions."}),"\n",(0,s.jsx)(n.p,{children:"Use Cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Preprocessor","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Passing one or more ",(0,s.jsx)(n.code,{children:"eezs"})," to a global clipping function that specifies optional EEZ boundaries to clip the sketch to in addition to removing land."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Geoprocessor","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Subregional planning. Passing one or more ",(0,s.jsx)(n.code,{children:"geographyIds"}),", as subregions within an EEZ. This can be used to when calculating results for all subregions at once doesn't make sense, or is computationally prohibitive. Instead you may want the user to be able to switch between subregions, and the reports will rerun the geoprocessing function with a different geography and update with the result on-demand."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"passing-extra-parameters-to-geoprocessing-functions",children:"Passing Extra Parameters To Geoprocessing Functions"}),"\n",(0,s.jsx)(n.p,{children:"Report developers will pass the extra parameters to a geoprocessing function via the ResultsCard. It must be an object where the keys can be any JSON-compatible value. Even nested objects and arrays are allowed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<ResultsCard\n  title={t("Size")}\n  functionName="boundaryAreaOverlap"\n  extraParams={{ geographyIds: ["nearshore", "offshore"] }}\n  useChildCard\n>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A common next step for this is to maintain the array of geographyIds in the parent Card, and potentially allow the user to change the values using a UI selector. If the value passed to ",(0,s.jsx)(n.code,{children:"extraParams"})," changes, the card will re-render itself, triggering the run of a new function, and displaying the results."]}),"\n",(0,s.jsxs)(n.p,{children:["Internally the ",(0,s.jsx)(n.a,{href:"https://github.com/seasketch/geoprocessing/blob/7275bd3ddf355259cf99335a761b99472045b6f8/packages/geoprocessing/src/components/ResultsCard.tsx",children:"ResultsCard"})," uses the ",(0,s.jsx)(n.a,{href:"https://github.com/seasketch/geoprocessing/blob/7275bd3/packages/geoprocessing/src/hooks/useFunction.ts#L44",children:"useFunction"})," hook, which accepts ",(0,s.jsx)(n.code,{children:"extraParams"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"useFunction('boundaryAreaOverlap', { geographyIds: ['santa-maria'] }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If invoking functions directly, such as SeaSketch invoking a preprocessing function, the ",(0,s.jsx)(n.code,{children:"extraParams"})," can be provided in the event body."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "feature": {...},\n  "extraParams": { "eezs": ["Azores"], "foos": "blorts", "nested": { "a": 3, "b": 4 }}\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"accessing-extra-parameters-in-functions",children:"Accessing Extra Parameters In Functions"}),"\n",(0,s.jsxs)(n.p,{children:["Both preprocessing and geoprocessing functions receive a second ",(0,s.jsx)(n.code,{children:"extraParams"})," parameter. The default type is ",(0,s.jsx)(n.code,{children:"Record<string, JSONValue>"})," but the implementer can provide a narrower type that defines explicit parameters."]}),"\n",(0,s.jsx)(n.p,{children:"Geoprocessing function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/** Optional caller-provided parameters */\ninterface ExtraParams {\n  /** Optional ID(s) of geographies to operate on. **/\n  geographyIds?: string[];\n}\n\nexport async function boundaryAreaOverlap(\n  sketch: Sketch<Polygon> | SketchCollection<Polygon>,\n  extraParams: ExtraParams = {}\n): Promise<ReportResult> {\n  const geographyIds = extraParams.geographyIds\n  console.log('Current geographies', geographyIds)\n  const results = runAnalysis(geographyIds)\n  return results\n"})}),"\n",(0,s.jsx)(n.p,{children:"Preprocessing function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'interface ExtraParams {\n  /** Array of EEZ ID\'s to clip to  */\n  eezs?: string[];\n}\n\n/**\n * Preprocessor takes a Polygon feature/sketch and returns the portion that\n * is in the ocean (not on land) and within one or more EEZ boundaries.\n */\nexport async function clipToOceanEez(\n  feature: Feature | Sketch,\n  extraParams: ExtraParams = {},\n): Promise<Feature> {\n  if (!isPolygonFeature(feature)) {\n    throw new ValidationError("Input must be a polygon");\n  }\n\n  /**\n   * Subtract parts of feature/sketch that overlap with land. Uses global land polygons\n   * unionProperty is specific to subdivided datasets.  When defined, it will fetch\n   * and rebuild all subdivided land features overlapping with the feature/sketch\n   * with the same gid property (assigned one per country) into one feature before clipping.\n   * This is useful for preventing slivers from forming and possible for performance.\n   */\n  const removeLand: DatasourceClipOperation = {\n    datasourceId: "global-clipping-osm-land",\n    operation: "difference",\n    options: {\n      unionProperty: "gid", // gid is assigned per country\n    },\n  };\n\n  /**\n   * Optionally, subtract parts of feature/sketch that are outside of one or\n   * more EEZ\'s.  Using a runtime-provided list of EEZ\'s via extraParams.\n   * eezFilterByNames allows this preprocessor to work for any set of EEZ\'s\n   * Using a project-configured planningAreaId allows this preprocessor to work\n   * for a specific EEZ.\n   */\n  const removeOutsideEez: DatasourceClipOperation = {\n    datasourceId: "global-clipping-eez-land-union",\n    operation: "intersection",\n    options: {\n      propertyFilter: {\n        property: "UNION",\n        values: extraParams?.eezs || [project.basic.planningAreaId] || [],\n      },\n    },\n  };\n\n  // Create a function that will perform the clip operations in order\n  const clipLoader = genClipLoader(project, [removeLand, removeOutsideEez]);\n\n  // Wrap clip function into preprocessing function with additional clip options\n  return clipToPolygonFeatures(feature, clipLoader, {\n    maxSize: 500000 * 1000 ** 2, // Default 500,000 KM\n    enforceMaxSize: false, // throws error if feature is larger than maxSize\n    ensurePolygon: true, // don\'t allow multipolygon result, returns largest if multiple\n  });\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"writing-smoke-tests-with-extraparams",children:"Writing smoke tests with extraParams"}),"\n",(0,s.jsx)(n.p,{children:"Default smoke tests typically don't pass extraParams to the preprocessing or geoprocessing function but they can. Just know that each smoke test can only output results for one configuration of extraParams. And storybook can only load results for one smoke test run.\nThis means that in order to test multiple variations of extraParams, you will need to create multiple smoke tests. You could even write multiple smoke tests that each write out results all in one file."}),"\n",(0,s.jsx)(n.p,{children:"Example smoke test (e.g. boundaryAreaOverlapExtraParamSmoke.test.ts):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'test("boundaryAreaOverlapSantaMariaSmoke - tests run with one subregion", async () => {\n  const examples = await getExamplePolygonSketchAll();\n  for (const example of examples) {\n    const result = await boundaryAreaOverlap(example, { geographyIds: [\'santa-maria\']});\n    expect(result).toBeTruthy();\n    writeResultOutput(result, "boundaryAreaOverlapSantaMaria", example.properties.name);\n  }\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);