"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[86180],{12754:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=n(74848),i=n(28453);const s={},a="Accuracy/Limitations",o={id:"EdgesAndLimits",title:"Accuracy/Limitations",description:"Javascript-only",source:"@site/docs/EdgesAndLimits.md",sourceDirName:".",slug:"/EdgesAndLimits",permalink:"/geoprocessing/docs/next/EdgesAndLimits",draft:!1,unlisted:!1,editUrl:"https://github.com/seasketch/geoprocessing/tree/main/website/templates/shared/docs/EdgesAndLimits.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Architecture",permalink:"/geoprocessing/docs/next/architecture"},next:{title:"Typescript API",permalink:"/geoprocessing/docs/next/api/"}},c={},l=[{value:"Javascript-only",id:"javascript-only",level:3},{value:"Coordinate System Support",id:"coordinate-system-support",level:3},{value:"Calculation Error",id:"calculation-error",level:3},{value:"TurfJS",id:"turfjs",level:4}];function d(e){const t={a:"a",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"accuracylimitations",children:"Accuracy/Limitations"})}),"\n",(0,r.jsx)(t.h3,{id:"javascript-only",children:"Javascript-only"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The geoprocessing library currently only supports geoprocessing functions that run in a NodeJS environment. You have the ability to invoke any Lambda function, the framework just doesn't have first class support for writing and publishing functions in any other languages."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"coordinate-system-support",children:"Coordinate System Support"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Vector data, on import, is converted to WGS 84 (EPSG 4326). Vector toolbox functions expect data to be in this projection."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Raster data, on import, is converted to an equal area projection (NSIDC EASE-Grid 2.0 Global)[",(0,r.jsx)(t.a,{href:"https://epsg.io/6933",children:"https://epsg.io/6933"}),"]."," Raster toolbox functions should work with any grid-based projection but anything other than equal area will have accuract issues."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Geoprocessing functions in this library currently only support GeoJSON data in the World Geodetic System 1984 (WGS 84) [WGS84] datum (aka Lat/Lon), with longitude and latitude units of decimal degrees."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"calculation-error",children:"Calculation Error"}),"\n",(0,r.jsx)(t.h4,{id:"turfjs",children:"TurfJS"}),"\n",(0,r.jsxs)(t.p,{children:["TurfJS vector function (particularly those that use ",(0,r.jsx)(t.a,{href:"http://turfjs.org/docs/#distance",children:"Turf.JS"}),") measure distance and area by approximating them on a sphere. Turf.js functions strike a balance between speed and accuracy."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"If the geographic area of your project is small, on the order of a few hundred to a thousand miles, and not at high latitudes (> 60), then the accuracy will be quite good, and the error quite small (within 5%) compared to more exact algorithms."}),"\n",(0,r.jsx)(t.li,{children:"And if your planning objectives target creating areas that capture a given % of something, for example 20% of the rocky reef habitat in the entire planning area, then the effect of error in area calculations should be limited to none as long as the area calculations are done using the same algorithms."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Sources:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://blog.mapbox.com/fast-geodesic-approximations-with-cheap-ruler-106f229ad016",children:"Fast Geodesic Approximations"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.movable-type.co.uk/scripts/latlong.html",children:"Calculate distance, bearing and more between Latitude/Longitude points"})}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Haversine_formula",children:"Haversine Formula on Wikipedia"}),". Used by ",(0,r.jsx)(t.a,{href:"https://github.com/Turfjs/turf/tree/master/packages/turf-distance",children:"turf-distance"}),". Error up to 0.5%"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://sgp1.digitaloceanspaces.com/proletarian-library/books/5cc63c78dc09ee09864293f66e2716e2.pdf",children:"Some algorithms for polygons on a sphere"})," - used by ",(0,r.jsx)(t.a,{href:"http://turfjs.org/docs/#area",children:"turf-area"}),". Greater error at higher latitudes vs. Vincenty."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Vincenty%27s_formulae",children:"Vincenty algorithm"})," used by ",(0,r.jsx)(t.a,{href:"https://github.com/Turfjs/turf-vincenty-inverse",children:"turf-vincenty-inverse"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://datatracker.ietf.org/doc/html/rfc7946#section-4",children:"GeoJSON spec WGS84 requirement"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(96540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);