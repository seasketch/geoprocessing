"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[46139],{36513:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var n=i(74848),s=i(28453);const o={},a="Subdividing Large Datasets",r={id:"tutorials/subdividing",title:"Subdividing Large Datasets",description:"If you have very large polygon datasets (think country or global data) with very large complex polygon, the standard data import process which uses flatgeobuf, may not be sufficient. An alternative is to use a VectorDataSource specially created by SeaSketch. It's based on a method described by Paul Ramsey in this article of subdividing your data, cutting it up along the boundaries of a spatial index.",source:"@site/docs/tutorials/subdividing.md",sourceDirName:"tutorials",slug:"/tutorials/subdividing",permalink:"/geoprocessing/docs/next/tutorials/subdividing",draft:!1,unlisted:!1,editUrl:"https://github.com/seasketch/geoprocessing/tree/main/website/templates/shared/docs/tutorials/subdividing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Extra Function Parameters",permalink:"/geoprocessing/docs/next/tutorials/extraParams"},next:{title:"Antimeridian",permalink:"/geoprocessing/docs/next/antimeridian"}},c={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"subdividing-large-datasets",children:"Subdividing Large Datasets"})}),"\n",(0,n.jsxs)(t.p,{children:["If you have very large polygon datasets (think country or global data) with very large complex polygon, the standard data import process which uses flatgeobuf, may not be sufficient. An alternative is to use a ",(0,n.jsx)(t.code,{children:"VectorDataSource"})," specially created by SeaSketch. It's based on a method described by Paul Ramsey in ",(0,n.jsx)(t.a,{href:"https://blog.cleverelephant.ca/2019/11/subdivide.html",children:"this article"})," of ",(0,n.jsx)(t.a,{href:"https://postgis.net/docs/ST_Subdivide.html",children:"subdividing"})," your data, cutting it up along the boundaries of a spatial index."]}),"\n",(0,n.jsx)(t.p,{children:"Once the polygons have been subdivided, they can be put into small files encoded in the geobuf format, and a lookup table created for the index. This entire bundle can be then put into S3 cloud storage."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://user-images.githubusercontent.com/511063/79161015-a0375e80-7d8f-11ea-87a9-0658777f2f90.jpg",alt:"subdivision process"})}),"\n",(0,n.jsxs)(t.p,{children:["The magic comes in being able to request polygons from this bundle in our geoprocessing functions. A ",(0,n.jsx)(t.code,{children:"VectorDataSource"})," class is available that lets us request only the polygon chunks from our subdivided bundle that overlap with the bounding box of our sketch that we are currently analyzing. It even caches request results locally so that subsequent requests do not call out to the network if needed."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"VectorDataSource"})," can also rebuild the polygon chunks back into the original polygons they came from. Imagine you've subdivide a dataset of country boundary polygons for the entire world. You've subdivided them, and now you can reconstruct them back into country polygons. You simply need to maintain an attribute with your polygons that uniquely identifies how they should be reconstructed. This could be a ",(0,n.jsx)(t.code,{children:"countryCode"})," or just a non-specific ",(0,n.jsx)(t.code,{children:"gid"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Here is an example of use end-to-end. Note this is quite a manual process. Future framework versions may try to automate it."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/mcclintock-lab/hawaii-reports-next/blob/main/data/eez-land-union-prep.sh",children:"data prep script"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/mcclintock-lab/hawaii-reports-next/blob/main/data/eez-land-union.sql",children:"sql subdivide script"})," run by the data prep script"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/mcclintock-lab/hawaii-reports-next/blob/main/data/eez-land-union-publish.sh",children:"publish script"})," brings the subdivided polygons out of postgis, encodes them in geobuf format, builds the index, and publishes it all to a standalone S3 bucket that is independent of your project. The url of the S3 bucket will be provided once complete. You can ``--dry-run` the command to see how many bundles it will create and how big they'll be. The sweet spot is bundles about ~25KB in size. Once you've found that sweet spot you can do the actual run."]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/mcclintock-lab/hawaii-reports-next/blob/main/src/functions/clipToOceanEez.ts#L32",children:"use of VectorDataSource in gp function"})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["This is the method that is used for the global ",(0,n.jsx)(t.code,{children:"land"})," and ",(0,n.jsx)(t.code,{children:"eez"})," datasources. Here is a full example of subdividing OpenStreetMap land polygons for the entire world. This is what is used for the ",(0,n.jsx)(t.code,{children:"clipToOceanEez"})," script that comes with the ",(0,n.jsx)(t.code,{children:"ocean-eez"})," starter template."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/mcclintock-lab/hawaii-reports-next/blob/main/data/eez-land-union-publish.sh",children:"publish vector data source"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>r});var n=i(96540);const s={},o=n.createContext(s);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);