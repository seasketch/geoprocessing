"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[17840],{72538:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var t=r(74848),s=r(28453);const o={},i="Worker Functions",c={id:"workers",title:"Worker Functions",description:"Worker functions are sync geoprocessing functions that are invoked directly by parent geoprocessing functions, allowing computationally intensive or memory intensive tasks to be split out across multiple lambdas. Worker results are assembled in the parent function and returned back to the report client",source:"@site/docs/workers.md",sourceDirName:".",slug:"/workers",permalink:"/geoprocessing/docs/next/workers",draft:!1,unlisted:!1,editUrl:"https://github.com/seasketch/geoprocessing/tree/main/website/templates/shared/docs/workers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Report Client",permalink:"/geoprocessing/docs/next/reportclient"},next:{title:"Custom Sketch Attributes",permalink:"/geoprocessing/docs/next/tutorials/sketchAttributes"}},a={},l=[];function p(e){const n={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"worker-functions",children:"Worker Functions"})}),"\n",(0,t.jsx)(n.p,{children:"Worker functions are sync geoprocessing functions that are invoked directly by parent geoprocessing functions, allowing computationally intensive or memory intensive tasks to be split out across multiple lambdas. Worker results are assembled in the parent function and returned back to the report client"}),"\n",(0,t.jsx)(n.p,{children:"Anytime you are making calculations on multiple things (datasets, geographies, sketches), there is potential to split it out across worker functions."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Multiple datasources"}),"\n",(0,t.jsx)(n.li,{children:"Sketch collection with multiple sketches"}),"\n",(0,t.jsx)(n.li,{children:"Multiple geographies"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of a parent geoprocessing function that invokes a worker for each geography:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import {\n  Sketch,\n  SketchCollection,\n  Polygon,\n  MultiPolygon,\n  GeoprocessingHandler,\n  DefaultExtraParams,\n  runLambdaWorker,\n  parseLambdaResponse,\n} from "@seasketch/geoprocessing";\nimport project from "../../project/projectClient.js";\nimport {\n  GeoprocessingRequestModel,\n  Metric,\n  ReportResult,\n  isMetricArray,\n  rekeyMetrics,\n  sortMetrics,\n  toNullSketch,\n} from "@seasketch/geoprocessing/client-core";\nimport { kelpMaxWorker } from "./kelpMaxWorker.js";\n\nexport async function kelpMax(\n  sketch:\n    | Sketch<Polygon | MultiPolygon>\n    | SketchCollection<Polygon | MultiPolygon>,\n  extraParams: DefaultExtraParams = {},\n  request?: GeoprocessingRequestModel<Polygon | MultiPolygon>,\n): Promise<ReportResult> {\n  const metricGroup = project.getMetricGroup("kelpMax");\n  const geographies = project.geographies;\n\n  const metrics = (\n    await Promise.all(\n      geographies.map(async (geography) => {\n        const parameters = {\n          ...extraParams,\n          geography: geography,\n          metricGroup,\n        };\n\n        return process.env.NODE_ENV === "test"\n          ? kelpMaxWorker(sketch, parameters)\n          : runLambdaWorker(\n              sketch,\n              project.package.name,\n              "kelpMaxWorker",\n              project.geoprocessing.region,\n              parameters,\n              request!,\n            );\n      }),\n    )\n  ).reduce<Metric[]>(\n    (metrics, result) =>\n      metrics.concat(\n        isMetricArray(result)\n          ? result\n          : (parseLambdaResponse(result) as Metric[]),\n      ),\n    [],\n  );\n\n  return {\n    metrics: sortMetrics(rekeyMetrics(metrics)),\n    sketch: toNullSketch(sketch, true),\n  };\n}\n\nexport default new GeoprocessingHandler(kelpMax, {\n  title: "kelpMax",\n  description: "kelpMax overlap",\n  timeout: 500, // seconds\n  memory: 1024, // megabytes\n  executionMode: "async",\n  // Specify any Sketch Class form attributes that are required\n  requiresProperties: [],\n  workers: ["kelpMaxWorker"],\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"Some things to notice:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The kelpMax function is configured as ",(0,t.jsx)(n.code,{children:"async"}),". Any geoprocessing function invoking workers will likely take long enough to run that it should just be async."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"workers"})," option is defined that registers a worker named ",(0,t.jsx)(n.code,{children:"kelpMaxWorker"}),". It is required on publish that there be another sync geoprocessing function with the title ",(0,t.jsx)(n.code,{children:"kelpMaxWorker"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"kelpMax is set to use relatively low memory, because all the work is being done by the workers."}),"\n",(0,t.jsxs)(n.li,{children:["The worker function is invoked using the ",(0,t.jsx)(n.a,{href:"/geoprocessing/docs/next/api/geoprocessing/functions/runLambdaWorker",children:"runLambdaWorker"})," utility function. This function invokes the lambda with the given name."]}),"\n",(0,t.jsxs)(n.li,{children:["kelpMaxWorker is being called once for each ",(0,t.jsx)(n.code,{children:"geography"})," and also the set of ",(0,t.jsx)(n.code,{children:"metricGroups"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["In the case of it being a test environment, then ",(0,t.jsx)(n.code,{children:"kelpMaxWorker"})," is run directly. This means that in a test environment all of the worker functions run on the same thread, which could overwhelm your system. Keep sketch examples as simple as possible for smoke tests."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of the worker function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export async function kelpMaxWorker(\n  sketch:\n    | Sketch<Polygon | MultiPolygon>\n    | SketchCollection<Polygon | MultiPolygon>,\n  extraParams: {\n    geography: Geography;\n    metricGroup: MetricGroup;\n  },\n) {\n  const geography = extraParams.geography;\n  const metricGroup = extraParams.metricGroup;\n\n  if (!metricGroup.datasourceId)\n    throw new Error(`Expected datasourceId for ${metricGroup.metricId}`);\n\n  // Support sketches crossing antimeridian\n  const splitSketch = splitSketchAntimeridian(sketch);\n\n  // Clip sketch to geography\n  const clippedSketch = await clipToGeography(splitSketch, geography);\n\n  // Get bounding box of sketch remainder\n  const sketchBox = clippedSketch.bbox || bbox(clippedSketch);\n\n  const ds = project.getDatasourceById(metricGroup.datasourceId);\n  if (!isRasterDatasource(ds))\n    throw new Error(`Expected raster datasource for ${ds.datasourceId}`);\n\n  const url = project.getDatasourceUrl(ds);\n\n  // Start raster load and move on in loop while awaiting finish\n  const raster = await loadCog(url);\n\n  // Start analysis when raster load finishes\n  const overlapResult = await rasterMetrics(raster, {\n    metricId: metricGroup.metricId,\n    feature: clippedSketch,\n    ...(ds.measurementType === "quantitative" && { stats: ["area"] }),\n    ...(ds.measurementType === "categorical" && {\n      categorical: true,\n      categoryMetricValues: metricGroup.classes.map((c) => c.classId),\n    }),\n  });\n\n  return overlapResult.map(\n    (metrics): Metric => ({\n      ...metrics,\n      classId: "kelpMax",\n      geographyId: geography.geographyId,\n    }),\n  );\n}\n\nexport default new GeoprocessingHandler(kelpMaxWorker, {\n  title: "kelpMaxWorker",\n  description: "",\n  timeout: 500, // seconds\n  memory: 1024, // megabytes\n  executionMode: "sync",\n  // Specify any Sketch Class form attributes that are required\n  requiresProperties: [],\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"Some things to notice:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The worker function receives the ",(0,t.jsx)(n.code,{children:"extraParams"})," passed by the parent geoprocessing function. This is no different than how a geoprocessing function receives ",(0,t.jsx)(n.code,{children:"extraParams"})," passed by a report client."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Other things to know:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caching of results in DynamoDB is disabled for workers. The thinking is that if the parent geoprocessing function results are cached, then the worker caches will never be accessed, at least not under current use cases, so they don't be created. This drastically reduces the number of DynamoDB items created for each report, keeping costs down."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For more examples see ",(0,t.jsx)(n.a,{href:"https://github.com/seasketch/california-reports/tree/main/src/functions",children:"california-reports"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var t=r(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);