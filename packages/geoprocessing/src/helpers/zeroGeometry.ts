import {
  Polygon,
  MultiPolygon,
  Sketch,
  SketchCollection,
} from "../types/index.js";

// Zero polygon geometry is generated by functions like clipToGeography in place of creating a null geometry
// because libraries like turf and @types/geojson don't really support null geometries completely
// using a zero polygon geometry allows us to still calculate metrics like area and overlap
// without having to worry about null geometries.  This should work out unless we do planning
// on null island

/**
 * Returns a zero polygon geometry (three [0,0] coordinates)
 * @param sketch
 */
export function zeroPolygon() {
  return {
    type: "Polygon",
    coordinates: [[[0, 0]], [[0, 0]], [[0, 0]]],
  };
}

/**
 * Given sketch, returns the mutated sketch with a zero polygon geometry (three [0,0] coordinates)
 * @param sketch
 */
export function zeroSketch<G extends Polygon | MultiPolygon>(
  sketch: Sketch,
): Sketch<G> {
  return {
    ...sketch,
    geometry: zeroPolygon() as G,
  };
}

/**
 * Given sketch array, returns the mutated sketches with a zero polygon geometry (three [0,0] coordinates)
 * @param sketch
 */
export function zeroSketchArray<G extends Polygon | MultiPolygon>(
  sketches: Sketch<G>[],
): Sketch<G>[] {
  return sketches.map((sketch: Sketch<G>) => zeroSketch(sketch));
}

/**
 * Given sketch collection, returns the mutated collection with all child sketches switched to have zero polygon geometry (three [0,0] coordinates)
 * @param sketchCollection
 */
export function zeroSketchCollection<G extends Polygon | MultiPolygon>(
  sketchCollection: SketchCollection<G>,
): SketchCollection<G> {
  return {
    ...sketchCollection,
    features: sketchCollection.features.map((sketch: Sketch<G>) =>
      zeroSketch(sketch),
    ),
  };
}
